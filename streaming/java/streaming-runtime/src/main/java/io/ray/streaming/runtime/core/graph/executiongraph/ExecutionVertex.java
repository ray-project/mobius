package io.ray.streaming.runtime.core.graph.executiongraph;

import com.google.common.base.Preconditions;
import io.ray.api.BaseActorHandle;
import io.ray.api.id.ActorId;
import io.ray.api.placementgroup.PlacementGroup;
import io.ray.streaming.api.Language;
import io.ray.streaming.common.config.ResourceConfig;
import io.ray.streaming.common.enums.OperatorType;
import io.ray.streaming.jobgraph.VertexType;
import io.ray.streaming.operator.StreamOperator;
import io.ray.streaming.runtime.core.resource.ContainerId;
import io.ray.streaming.runtime.core.resource.ResourceType;
import io.ray.streaming.runtime.master.scheduler.ExecutionBundle;
import io.ray.streaming.runtime.rpc.remoteworker.WorkerCaller;
import io.ray.streaming.runtime.transfer.channel.ChannelId;
import io.ray.streaming.runtime.worker.JobWorkerType;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;

/** Physical vertex, correspond to {@link ExecutionJobVertex}. */
public class ExecutionVertex implements Serializable {

  /** Unique id for execution vertex. */
  private final int executionVertexId;

  /** Immutable field inherited from {@link ExecutionJobVertex}. */
  private final int executionJobVertexId;

  private final String executionJobVertexName;
  private final StreamOperator operator;
  private final VertexType vertexType;
  private final Language language;
  private final long buildTime;

  /** Resource used by ExecutionVertex. */
  private final Map<String, Double> resource;

  /** Parallelism of current vertex's operator. */
  private int parallelism;

  /**
   * Ordered sub index for execution vertex in a execution job vertex. Might be changed in dynamic
   * scheduling.
   */
  private int executionVertexIndex;

  private ExecutionJobVertexState jobVertexState = ExecutionJobVertexState.NORMAL;
  private ExecutionVertexState state = ExecutionVertexState.TO_ADD;

  /** The id of the container which this vertex's worker actor belongs to. */
  private ContainerId containerId;

  private String pid;

  /** Worker actor handle. */
  private BaseActorHandle workerActor; // deprecated

  /**
   * For remote call of different type workers, like: `JavaWorker` `DynamicPyWorker` `PythonWorker`
   * i.e. python tide worker Here we use workerCaller to replace workerActor to make remote call
   * more convenient.
   */
  private WorkerCaller workerCaller;

  private ExecutionBundle executionBundle;

  /**
   * Role indicate the operator position in the DAG, which need to be distinguished to do things
   * like broadcast barrier from the sources.
   */
  private OperatorType roleInChangedSubDag = OperatorType.TRANSFORM;

  /** job config. */
  private Map<String, String> jobConfig;

  private List<ExecutionEdge> inputEdges = new ArrayList<>();
  private List<ExecutionEdge> outputEdges = new ArrayList<>();

  private transient List<String> inputChannelIdList;
  private transient List<String> outputChannelIdList;

  private transient Map<String, BaseActorHandle> channelIdInputActorMap;
  private transient Map<String, BaseActorHandle> channelIdOutputActorMap;
  private Map<Integer, String> exeVertexChannelMap;

  public ExecutionVertex(
      int globalId,
      int index,
      ExecutionJobVertex executionJobVertex,
      ResourceConfig resourceConfig) {
    this.executionVertexId = globalId;
    this.executionJobVertexId = executionJobVertex.getExecutionJobVertexId();
    this.executionJobVertexName = executionJobVertex.getExecutionJobVertexName();
    this.operator = executionJobVertex.getStreamOperator();
    this.vertexType = executionJobVertex.getVertexType();
    this.language = executionJobVertex.getLanguage();
    this.buildTime = executionJobVertex.getBuildTime();
    this.parallelism = executionJobVertex.getParallelism();
    this.executionVertexIndex = index;
    this.resource = generateResourceMap(resourceConfig);
    this.jobConfig = new HashMap<>(executionJobVertex.getJobConfig());
  }

  public int getExecutionVertexId() {
    return executionVertexId;
  }

  /**
   * Unique name generated by execution job vertex name and index of current execution vertex. e.g.
   * 1-ISourceOperator-3 (vertex index is 3)
   */
  public String getExecutionVertexName() {
    return executionJobVertexName + "-" + executionVertexIndex;
  }

  public int getExecutionJobVertexId() {
    return executionJobVertexId;
  }

  public String getExecutionJobVertexName() {
    return executionJobVertexName;
  }

  public StreamOperator getOperator() {
    return operator;
  }

  public VertexType getVertexType() {
    return vertexType;
  }

  public Language getLanguage() {
    return language;
  }

  public int getParallelism() {
    return parallelism;
  }

  public void setParallelism(int parallelism) {
    this.parallelism = parallelism;
  }

  public OperatorType getRoleInChangedSubDag() {
    return roleInChangedSubDag;
  }

  public void setRoleInChangedSubDag(OperatorType roleInChangedSubDag) {
    this.roleInChangedSubDag = roleInChangedSubDag;
  }

  public ExecutionBundle getExecutionBundle() {
    return executionBundle;
  }

  public int getBundleIndex() {
    if (executionBundle != null) {
      return executionBundle.getIndex();
    }
    return -1;
  }

  public PlacementGroup getPlacementGroup() {
    if (executionBundle != null) {
      return executionBundle.getPlacementGroup();
    }
    return null;
  }

  public void setExecutionBundle(ExecutionBundle executionBundle) {
    this.executionBundle = executionBundle;
  }

  public int getExecutionVertexIndex() {
    return executionVertexIndex;
  }

  public ExecutionVertexState getState() {
    return state;
  }

  public void setState(ExecutionVertexState state) {
    this.state = state;
  }

  public boolean isToAdd() {
    return ExecutionVertexState.TO_ADD.equals(state);
  }

  public boolean isRunning() {
    return ExecutionVertexState.RUNNING.equals(state);
  }

  public boolean isToUpdate() {
    return getState() == ExecutionVertexState.TO_ADD_RELATED
        || getState() == ExecutionVertexState.TO_DEL_RELATED
        || getState() == ExecutionVertexState.TO_UPDATE;
  }

  public boolean isToDelete() {
    return ExecutionVertexState.TO_DEL.equals(state);
  }

  public boolean isToChange() {
    return isToAdd() || isToDelete();
  }

  public boolean isEmptyWorkerCaller() {
    return workerCaller == null;
  }

  public BaseActorHandle getActor() {
    return workerActor;
  }

  public WorkerCaller getWorkerCaller() {
    Preconditions.checkNotNull(workerCaller, getActorFullName() + "'s worker caller is empty.");
    return workerCaller;
  }

  public String getActorFullName() {
    return getExecutionVertexName() + "|" + executionVertexId;
  }

  public void setActor(BaseActorHandle workerActor) {
    this.workerActor = workerActor;
  }

  public List<ExecutionEdge> getInputEdges() {
    return inputEdges;
  }

  public void setInputEdges(List<ExecutionEdge> inputEdges) {
    this.inputEdges = inputEdges;
  }

  public List<ExecutionEdge> getOutputEdges() {
    return outputEdges;
  }

  public void setOutputEdges(List<ExecutionEdge> outputEdges) {
    this.outputEdges = outputEdges;
  }

  public List<ExecutionVertex> getInputExecutionVertices() {
    return inputEdges.stream().map(ExecutionEdge::getSource).collect(Collectors.toList());
  }

  public List<ExecutionVertex> getOutputExecutionVertices() {
    return outputEdges.stream().map(ExecutionEdge::getTarget).collect(Collectors.toList());
  }

  public ActorId getWorkerActorId() {
    return null == workerActor ? null : workerActor.getId();
  }

  public String getActorName() {
    return String.valueOf(executionVertexId);
  }

  public Map<String, Double> getResource() {
    return resource;
  }

  public void updateRequiredResource(String resourceKey, Double resourceValue) {
    if (!StringUtils.isEmpty(resourceKey) && resourceValue > 0) {
      resource.put(resourceKey, resourceValue);
    }
  }

  public void updateRequiredResources(Map<String, Double> resources) {
    for (Map.Entry<String, Double> resource : resources.entrySet()) {
      updateRequiredResource(resource.getKey(), resource.getValue());
    }
  }

  public long getBuildTime() {
    return buildTime;
  }

  public ContainerId getContainerId() {
    return containerId;
  }

  public void setContainerId(ContainerId containerId) {
    this.containerId = containerId;
  }

  public String getPid() {
    return pid;
  }

  public void setPid(String pid) {
    this.pid = pid;
  }

  public void setContainerIfNotExist(ContainerId containerId) {
    if (null == this.containerId) {
      this.containerId = containerId;
    }
  }

  public Map<String, String> getOpConfig() {
    return operator.getOpConfig();
  }

  public Map<String, String> getJobConfig() {
    return jobConfig;
  }

  /*---------channel-actor relations---------*/
  public List<String> getOutputChannelIdList() {
    if (outputChannelIdList == null) {
      generateActorChannelInfo();
    }
    return outputChannelIdList;
  }

  public Map<String, BaseActorHandle> getChannelIdOutputActorMap() {
    if (channelIdOutputActorMap == null) {
      generateActorChannelInfo();
    }
    return channelIdOutputActorMap;
  }

  public List<String> getInputChannelIdList() {
    if (inputChannelIdList == null) {
      generateActorChannelInfo();
    }
    return inputChannelIdList;
  }

  public Map<String, BaseActorHandle> getChannelIdInputActorMap() {
    if (channelIdInputActorMap == null) {
      generateActorChannelInfo();
    }
    return channelIdInputActorMap;
  }

  public String getChannelIdByPeerVertex(ExecutionVertex peerVertex) {
    if (exeVertexChannelMap == null) {
      generateActorChannelInfo();
    }
    return exeVertexChannelMap.get(peerVertex.getExecutionVertexId());
  }

  /**
   * Gets the job worker type according to the language and process.
   *
   * @return JobWorkerType
   */
  public JobWorkerType getJobWorkerType() {
    if (language == Language.JAVA) {
      return JobWorkerType.JAVA_WORKER;
    } else {
      return JobWorkerType.PYTHON_WORKER;
    }
  }

  private void generateActorChannelInfo() {
    inputChannelIdList = new ArrayList<>();
    channelIdInputActorMap = new HashMap<>();
    outputChannelIdList = new ArrayList<>();
    channelIdOutputActorMap = new HashMap<>();
    exeVertexChannelMap = new HashMap<>();

    List<ExecutionEdge> inputEdges = getInputEdges();
    for (ExecutionEdge edge : inputEdges) {
      String channelId =
          ChannelId.genIdStr(
              edge.getSource().getExecutionVertexId(), getExecutionVertexId(), getBuildTime());
      inputChannelIdList.add(channelId);
      channelIdInputActorMap.put(channelId, edge.getSource().getActor());
      exeVertexChannelMap.put(edge.getSource().getExecutionVertexId(), channelId);
    }

    List<ExecutionEdge> outputEdges = getOutputEdges();
    for (ExecutionEdge edge : outputEdges) {
      String channelId =
          ChannelId.genIdStr(
              getExecutionVertexId(), edge.getTarget().getExecutionVertexId(), getBuildTime());
      outputChannelIdList.add(channelId);
      channelIdOutputActorMap.put(channelId, edge.getTarget().getActor());
      exeVertexChannelMap.put(edge.getTarget().getExecutionVertexId(), channelId);
    }
  }

  private Map<String, Double> generateResourceMap(ResourceConfig resourceConfig) {
    Map<String, Double> resourceMap = new HashMap<>();
    if (resourceConfig.isTaskCpuResourceLimit()) {
      resourceMap.put(ResourceType.CPU.name(), resourceConfig.taskCpuResource());
    }
    if (resourceConfig.isTaskMemResourceLimit()) {
      resourceMap.put(ResourceType.MEM.name(), resourceConfig.taskMemResource());
    }
    return resourceMap;
  }

  public boolean isChangedOrAffected() {
    return !jobVertexState.equals(ExecutionJobVertexState.NORMAL);
  }

  public void markAsChanged() {
    jobVertexState = ExecutionJobVertexState.CHANGED;
  }

  public void markAsNormal() {
    jobVertexState = ExecutionJobVertexState.NORMAL;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof ExecutionVertex) {
      return this.executionVertexId == ((ExecutionVertex) obj).getExecutionVertexId();
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(executionVertexId, outputEdges);
  }

  @Override
  public String toString() {
    return "ExecutionVertex{"
        + "executionVertexId="
        + executionVertexId
        + ", executionJobVertexName='"
        + executionJobVertexName
        + '\''
        + ", resource="
        + resource
        + ", state="
        + state
        + ", actorId='"
        + getWorkerActorId()
        + '\''
        + ", roleInChangedSubDag="
        + roleInChangedSubDag
        + ", pid='"
        + pid
        + '\''
        + '}';
  }
}
